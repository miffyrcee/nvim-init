snippet mod
	module `substitute(substitute(expand('%:r'), '[/\\]','.','g'),'^\%(\l*\.\)\?','','')`
		(
		) where

	import Prelude

	${0}
endsnippet
snippet imp
	import ${0:Data.List}
endsnippet
snippet impq
	import ${1:Data.List} as ${0:List}
endsnippet
snippet fn0
	${1:name} :: ${2:a}
	$1 = ${0:undefined}
endsnippet
snippet fn
	${1:fn} :: ${2:a} -> ${3:a}
	$1 ${4}= ${0}
endsnippet
snippet fn1
	${1:fn} :: ${2:a} -> ${3:a}
	$1 ${4}= ${0}
endsnippet
snippet fn2
	${1:fn} :: ${2:a} -> ${3:a} -> ${4:a}
	$1 ${5}= ${0}
endsnippet
snippet fn3
	${1:fn} :: ${2:a} -> ${3:a} -> ${4:a} -> ${5:a}
	$1 ${6}= ${0}
endsnippet
snippet case
	case ${1} of
		${2} -> ${0}
endsnippet
snippet let
	let
		${1} = ${2}
	in
		${3}
endsnippet
snippet where
	where
		${1} = ${0}
endsnippet
snippet testunit
	module Test.Main where

	import Prelude
	import Test.Unit (suite, test)
	import Test.Unit.Main (runTest)
	import Test.Unit.Assert as Assert

	main = runTest do
		suite "${1}" do
			test "${2:the tests run}" do
				Assert.equal
					"Hello, world!"
					"Hello, sailor!"
endsnippet
snippet if
	if ${1} then
		${2:${VISUAL}}
	else
		${0}
endsnippet
snippet doc
	{-| ${0}
	-}
endsnippet
snippet ty
	type ${1:Type} =
		${0}
endsnippet
snippet da
	data ${1:Type} =
		${0:$1}
endsnippet
snippet nty
	newtype ${1:Type} =
		${2:$1} ${0:Int}
endsnippet
snippet fi
	foreign import ${1} :: ${2}
endsnippet
